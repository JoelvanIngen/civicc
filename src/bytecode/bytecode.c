/**
 * @file
 *
 * Traversal: ByteCodeGeneration
 * UID      : BC
 *
 *
 */

#include "ccn/ccn.h"
#include "ccngen/ast.h"
#include "ccngen/trav.h"

#include "common.h"
#include "asm.h"
#include "writer.h"
#include "global/globals.h"
#include "symbol/scopetree.h"
#include "symbol/table.h"

static FILE* ASM_FILE;
static Assembly ASM;

static SymbolTable* CURRENT_SCOPE;

static size_t CONST_COUNT = 0;

static size_t NUMBERED_LABEL_COUNT = 0;

static ValueType LAST_TYPE = VT_NULL;
static bool HAD_EXPR = false;

// Checks whether a return statement is issued (or if we need to implicitly add one in case of void)
static bool HAD_RETURN = false;

// Shortcuts to prevent having to provide asm as argument every call
void Instr(char* instr_name, char* arg0, char* arg1, char* arg2) {
    ASMemitInstr(&ASM, instr_name, arg0, arg1, arg2);
}

void Label(char* label, bool is_fun) {
    ASMemitLabel(&ASM, label, is_fun);
}

char** generate_vt_strs(const ValueType* vts, const size_t len) {
    char** strs = MEMmalloc(len * sizeof(char*));
    for (size_t i = 0; i < len; i++) {
        strs[i] = vt_to_str(vts[i]);
    }
    return strs;
}

static FunExportEntry find_fun_export(char* name) {
    const FunExportEntry res = ASMfindFunExport(&ASM, name);
#ifdef DEBUGGING
    ASSERT_MSG((res.get != 0), "Result of retrieving known exported function yielded no results");
#endif // DEBUGGING
    return res;
}

static FunImportEntry find_fun_import(char* name) {
    const FunImportEntry res = ASMfindFunImport(&ASM, name);
#ifdef DEBUGGING
    ASSERT_MSG((res.get != 0), "Result of retrieving known imported function yielded no results");
#endif // DEBUGGING
    return res;
}

/**
 * Generates a guaranteed unique name for any given nested function that
 * cannot be generated by a user function
 * @param s function header symbol to generate name for
 * @return unique name
 */
char* generate_unique_fun_name(const Symbol* s) {
    char* name = STRcpy(s->name);

    // Don't generate name for exported function
    if (s->exported) return name;

    while (s->parent_scope->parent_fun != NULL) {
        s = s->parent_scope->parent_fun;
        name = safe_concat_str(s->name, name);
    }

    return safe_concat_str(STRcpy("_"), name);
}

/**
 * Generates a unique label name that is guaranteed not to collide with
 * any existing names
 * @param name name to append to unique part of name
 * @return unique name
 */
char* generate_label_name(char* name) {
    char* res = safe_concat_str(STRcpy("_lab"), int_to_str((int) NUMBERED_LABEL_COUNT++));
    res = safe_concat_str(res, STRcpy("_"));
    return safe_concat_str(res, name);
}

void add_importvars() {
    // Run loop multiple times to get the highest offset imported since they are not stored in order
    // in the hashtable, but they need to be written to the file in order
    int highest_found = -1;
    int highest_saved = -1;

    int prev_highest_saved = highest_saved;
    do {
        for (htable_iter_st *iter = HTiterate(GB_GLOBAL_SCOPE->table); iter;
                iter = HTiterateNext(iter)) {
            const Symbol *s = HTiterValue(iter);

            if (s->imported) {
                if ((int) s->offset > highest_found) highest_found = (int) s->offset;
                if ((int) s->offset == highest_saved + 1) {
                    // TODO: Save the thing
                    highest_saved++;
                }
            }
        }

#ifdef DEBUGGING
        if (highest_saved == prev_highest_saved && highest_found != highest_saved) {
            ERROR("Loop stuck; highest found: %i, highest saved: %i", highest_found, highest_saved);
        }
#endif // DEBUGGING
    } while (highest_found != highest_saved);
}

static void init() {
    CURRENT_SCOPE = GB_GLOBAL_SCOPE;

    add_importvars();
}

static void fini() {
    ASM_FILE = fopen(global.output_file, "w");
    if (ASM_FILE == NULL) {
        fprintf(stderr, "Error creating bytecode file");
        exit(1);
    }
    write_assembly(ASM_FILE, &ASM);
    fclose(ASM_FILE);

    // Free memory
    STfree(&GB_GLOBAL_SCOPE);
}

/**
 * @fn BCprogram
 */
node_st *BCprogram(node_st *node)
{
    init();

    TRAVchildren(node);

    // Write collected ASM to file
    fini();
    return node;
}

/**
 * @fn BCdecls
 */
node_st *BCdecls(node_st *node)
{
    TRAVchildren(node);

    /**
     * Do nothing
     */
    return node;
}

/**
 * @fn BCexprs
 */
node_st *BCexprs(node_st *node)
{
    TRAVchildren(node);

    /**
     * Do nothing
     */
    return node;
}

/**
 * @fn BCarrexpr
 */
node_st *BCarrexpr(node_st *node)
{
    TRAVchildren(node);

    /**
     * TODO: No idea
     */
    return node;
}

/**
 * @fn BCids
 */
node_st *BCids(node_st *node)
{
    TRAVchildren(node);

    /**
     * TODO: No idea
     */
    return node;
}

/**
 * @fn BCexprstmt
 */
node_st *BCexprstmt(node_st *node)
{
    TRAVchildren(node);

    switch (LAST_TYPE) {
        case VT_NUM: Instr("ipop", NULL, NULL, NULL); break;
        case VT_FLOAT: Instr("fpop", NULL, NULL, NULL); break;
        case VT_BOOL: Instr("bpop", NULL, NULL, NULL); break;
        case VT_VOID: break;  // Special case: void function does not return anything to needs be popped
        default:  // Should never occur
#ifdef DEBUGGING
            ERROR("Unexpected exprstmt type %s", vt_to_str(LAST_TYPE));
#endif // DEBUGGING
    }

    /**
     * Pop value, it wasn't assigned to anything
     */
    return node;
}

/**
 * @fn BCreturn
 */
node_st *BCreturn(node_st *node)
{
    TRAVchildren(node);

    switch (CURRENT_SCOPE->parent_fun->vtype) {
        case VT_NUM: Instr("ireturn", NULL, NULL, NULL); break;
        case VT_FLOAT: Instr("freturn", NULL, NULL, NULL); break;
        case VT_BOOL: Instr("breturn", NULL, NULL, NULL); break;
        case VT_VOID: Instr("return", NULL, NULL, NULL); break;
        default:  // Should never occur
#ifdef DEBUGGING
            ERROR("Unexpected return valuetype %i", CURRENT_SCOPE->parent_fun->vtype);
#endif // DEBUGGING
    }

    HAD_RETURN = true;

    /**
     * Emit return instruction (with correct type)
     */
    return node;
}

/**
 * @fn BCfuncall
 */
node_st *BCfuncall(node_st *node)
{
    // TODO: Correctly handle calls to external functions

    char* name = FUNCALL_NAME(node);
    const Symbol* s = ScopeTreeFind(CURRENT_SCOPE, name);
#ifdef DEBUGGING
    ASSERT_MSG((s != NULL), "BYTECODE: Could not find symbol named %s", name);
#endif // DEBUGGING

    const size_t current_level = CURRENT_SCOPE->parent_fun->parent_scope->nesting_level;
    const size_t fun_level = s->parent_scope->nesting_level;
    const size_t fun_offset = s->offset;

    if (fun_level == 0) {
        // Global function
        Instr("isrg", NULL, NULL, NULL);
    } else if (fun_level == current_level + 1) {
        // Function defined inside current scope
        Instr("isrl", NULL, NULL, NULL);
    } else if (current_level == fun_level) {
        // "Sister function", both defined in the same scope
        Instr("isr", NULL, NULL, NULL);
    } else {
#ifdef DEBUGGING
        ASSERT_MSG((current_level >= fun_level + 1), "Calling function from scope depth %lu unreachable by own scope depth %lu",
            fun_level, current_level);
#endif // DEBUGGING
        char* delta_level = int_to_str((int) (current_level - fun_level));
        Instr("isr", delta_level, NULL, NULL);
        MEMfree(delta_level);
    }

    TRAVchildren(node);

    if (s->imported) {
        const size_t offset = find_fun_import(name).offset;
        char* offset_str = int_to_str((int) offset);
        Instr("jsre", offset_str, NULL, NULL);
        MEMfree(offset_str);
    } else {
        char* var_count_str = int_to_str((int) s->as.fun.scope->localvar_offset_counter);
        Instr("jsr", var_count_str, s->as.fun.label_name, NULL);
        MEMfree(var_count_str);
    }

    HAD_EXPR = true;
    LAST_TYPE = s->vtype;

    /**
     * For each argument:
     * -- Emit load for argument
     * Find out which scope function is from for funcall instruction?
     * Emit funcall instruction with amount of vars added
     */
    return node;
}

/**
 * @fn BCcast
 */
node_st *BCcast(node_st *node) {
    TRAVchildren(node);

    // INTEGER AND FLOAT
    if (LAST_TYPE == VT_NUM && CAST_TYPE(node) == CT_float) {
        Instr("i2f", NULL, NULL, NULL);
    } else if (LAST_TYPE == VT_FLOAT && CAST_TYPE(node) == CT_int) {
        Instr("f2i", NULL, NULL, NULL);
    }

    // BOOLEAN AND INTEGER
    else if (LAST_TYPE == VT_NUM && CAST_TYPE(node) == CT_bool) {
        /* Create instructions for
         * if ([lastvalue] != 0) {
         *     [push] true
         * } else {
         *     [push] false
         * }
         */

        char* else_label_name = generate_label_name(STRcpy("else"));
        char* endif_label_name = generate_label_name(STRcpy("end"));

        Instr("iloadc_0", NULL, NULL, NULL);
        Instr("ine", NULL, NULL, NULL);
        Instr("branch_f", else_label_name, NULL, NULL);
        Instr("bloadc_t", NULL, NULL, NULL);
        Instr("jump", endif_label_name, NULL, NULL);
        Label(else_label_name, false);
        Instr("bloadc_f", NULL, NULL, NULL);
        Label(endif_label_name, false);

        MEMfree(else_label_name);
        MEMfree(endif_label_name);
    } else if (LAST_TYPE == VT_BOOL && CAST_TYPE(node) == CT_int) {
        /* Create instructions for
         * if ([lastvalue]) {
         *     [push] 1
         * } else {
         *     [push] 0
         * }
         */

        char* else_label_name = generate_label_name(STRcpy("else"));
        char* endif_label_name = generate_label_name(STRcpy("end"));

        Instr("branch_f", else_label_name, NULL, NULL);
        Instr("iloadc_1", NULL, NULL, NULL);
        Instr("jump", endif_label_name, NULL, NULL);
        Label(else_label_name, false);
        Instr("iloadc_0", NULL, NULL, NULL);
        Label(endif_label_name, false);

        MEMfree(else_label_name);
        MEMfree(endif_label_name);
    }

    // BOOLEAN AND FLOAT
    else if (LAST_TYPE == VT_FLOAT && CAST_TYPE(node) == CT_bool) {
        /* Create instructions for
         * if ([lastvalue] != 0.0) {
         *     [push] true
         * } else {
         *     [push] false
         * }
         */

        char* else_label_name = generate_label_name(STRcpy("else"));
        char* endif_label_name = generate_label_name(STRcpy("end"));

        Instr("floadc_0", NULL, NULL, NULL);
        Instr("fne", NULL, NULL, NULL);
        Instr("branch_f", else_label_name, NULL, NULL);
        Instr("bloadc_t", NULL, NULL, NULL);
        Instr("jump", endif_label_name, NULL, NULL);
        Label(else_label_name, false);
        Instr("bloadc_f", NULL, NULL, NULL);
        Label(endif_label_name, false);

        MEMfree(else_label_name);
        MEMfree(endif_label_name);
    } else if (LAST_TYPE == VT_BOOL && CAST_TYPE(node) == CT_float) {
        /* Create instructions for
         * if ([lastvalue]) {
         *     [push] 1.0
         * } else {
         *     [push] 0.0
         * }
         */

        char* else_label_name = generate_label_name(STRcpy("else"));
        char* endif_label_name = generate_label_name(STRcpy("end"));

        Instr("branch_f", else_label_name, NULL, NULL);
        Instr("floadc_1", NULL, NULL, NULL);
        Instr("jump", endif_label_name, NULL, NULL);
        Label(else_label_name, false);
        Instr("floadc_0", NULL, NULL, NULL);
        Label(endif_label_name, false);

        MEMfree(else_label_name);
        MEMfree(endif_label_name);
    } else {
        // Should never occur
#ifdef DEBUGGING
        ERROR("Unexpected cast from VT type %s to CT type %i", vt_to_str(LAST_TYPE), CAST_TYPE(node));
#endif // DEBUGGING
    }

    LAST_TYPE = ct_to_vt(CAST_TYPE(node), false);

    /**
     * Traverse children
     * Emit cast
     */
    return node;
}

/**
 * @fn BCfundefs
 */
node_st *BCfundefs(node_st *node)
{
    TRAVchildren(node);

    /**
     * Do nothing
     */
    return node;
}

/**
 * @fn BCfundef
 */
node_st *BCfundef(node_st *node)
{
    char* name = FUNDEF_NAME(node);
    const Symbol* fun_symbol = ScopeTreeFind(CURRENT_SCOPE, name);
    const FunData* fun_data = &fun_symbol->as.fun;

    // Save function to export list if export
    if (fun_symbol->exported) {
        ASMemitFunExport(
            &ASM,
            name,
            vt_to_str(fun_symbol->vtype),
            fun_data->param_count,
            generate_vt_strs(fun_data->param_types, fun_data->param_count));
    }

    // Save function to import list if import
    else if (fun_symbol->imported) {
        ASMemitFunImport(
            &ASM,
            name,
            vt_to_str(fun_symbol->vtype),
            fun_data->param_count,
            generate_vt_strs(fun_data->param_types, fun_data->param_count));
    }

    // Switch scopes and traverse if not external function
    if (!fun_symbol->imported) {
        // Switch scope
        SymbolTable* prev_scope = CURRENT_SCOPE;
        CURRENT_SCOPE = fun_symbol->as.fun.scope;

        TRAVchildren(node);

        // Reset loop counter
        CURRENT_SCOPE->for_loop_counter = 0;

        // Revert scope
        CURRENT_SCOPE = prev_scope;
    }


    /**
    * Switch scopes if not imported
    */
    return node;
}

/**
 * @fn BCfunbody
 */
node_st *BCfunbody(node_st *node)
{
    TRAVlocal_fundefs(node);

    HAD_RETURN = false;
    char* label_name = generate_unique_fun_name(CURRENT_SCOPE->parent_fun);
    CURRENT_SCOPE->parent_fun->as.fun.label_name = STRcpy(label_name);
    Label(label_name, true);
    MEMfree(label_name);

    // Only write "esr" if at least one variable (NOT PARAMETER) will be initialised
    if (CURRENT_SCOPE->localvar_offset_counter
        - CURRENT_SCOPE->parent_fun->as.fun.param_count > 0) {

        char* offset_str = int_to_str((int) CURRENT_SCOPE->localvar_offset_counter);
        Instr("esr", offset_str, NULL, NULL);
        MEMfree(offset_str);
    }

    TRAVdecls(node);
    TRAVstmts(node);

    // Add a void return if the code doesn't contain a return statement
    if (CURRENT_SCOPE->parent_fun->vtype == VT_VOID) {
        if (!HAD_RETURN) {
            Instr("return", NULL, NULL, NULL);
        }
    }

    /**
     * Traverse nested functions (otherwise functions mix in bytecode)
     * Emit function label
     * Emit "esr N" with N being the amount of variables we are going to use in function
     * Traverse decls and stmts
     * !!! TODO: figure out a way to find the amount of variables used in function || Solved?
     * !!! TODO: figure out if for-loop variables count for that purpose (would make everything a tad trickier)
     */
    return node;
}

/**
 * @fn BCifelse
 */
node_st *BCifelse(node_st *node)
{
    char* else_label_name = generate_label_name(STRcpy("else"));
    char* endif_label_name = generate_label_name(STRcpy("end"));

    TRAVcond(node);

    Instr("branch_f", else_label_name, NULL, NULL);

    TRAVthen(node);

    Instr("jump", endif_label_name, NULL, NULL);
    Label(else_label_name, false);

    TRAVelse_block(node);

    Label(endif_label_name, false);

    MEMfree(else_label_name);
    MEMfree(endif_label_name);

    /**
     * Traverse cond child
     * Emit jump to label else if false
     * Traverse then child
     * Emit unconditional jump to label endif
     * Emit label else
     * Traverse else child (might be empty which yields same result following these steps)
     * Emit label endif
     */
    return node;
}

/**
 * @fn BCwhile
 */
node_st *BCwhile(node_st *node)
{
    char* while_start_name = generate_label_name(STRcpy("while_loop_start"));
    char* while_end_name = generate_label_name(STRcpy("while_loop_end"));

    Label(while_start_name, false);

    TRAVcond(node);

    Instr("branch_f", while_end_name, NULL, NULL);

    TRAVblock(node);

    Instr("jump", while_start_name, NULL, NULL);

    Label(while_end_name, false);

    MEMfree(while_start_name);
    MEMfree(while_end_name);

    /**
     * Emit loop start label
     * Traverse cond child
     * Emit jump to loop end label if false (expr will have resolved to boolean)
     * Traverse body
     * Emit unconditional jump to loop start label
     * Emit loop end label
     */
    return node;
}

/**
 * @fn BCdowhile
 */
node_st *BCdowhile(node_st *node)
{
    char* while_start_name = generate_label_name(STRcpy("while_loop_start"));

    Label(while_start_name, false);

    TRAVblock(node);

    TRAVcond(node);

    Instr("branch_t", while_start_name, NULL, NULL);

    MEMfree(while_start_name);

    /**
     * Emit loop start label
     * Traverse body
     * Traverse cond child
     * Emit jump to loop end label if false (expr will have resolved to boolean)
     * Emit unconditional jump to loop start label
     * Emit loop end label
     */

    return node;
}

/**
 * @fn BCfor
 */
node_st *BCfor(node_st *node)
{
    // TODO: For-loop variables will have wrong offset since they are in a separate scope
    // TODO continuation: Adjust parent offset counter and for-loop variable offset to
    // TODO continuation: compensate

    // Switch to loop scope
    const char* name = FOR_VAR(node);
    char* adjusted_name = safe_concat_str(
        int_to_str((int) CURRENT_SCOPE->for_loop_counter),
        safe_concat_str(STRcpy("_"), STRcpy(name)));
    const Symbol* s_loop = STlookup(CURRENT_SCOPE, adjusted_name);
    CURRENT_SCOPE = s_loop->as.forloop.scope;

    // Generate bytecode
    char* for_loop_start_name = generate_label_name(STRcpy("for_loop_start"));
    char* for_loop_end_name = generate_label_name(STRcpy("for_loop_end"));

    // TODO: Find incremented variable + increment

    // Special case: restore loop counter to zero for next traversal
    CURRENT_SCOPE->for_loop_counter = 0;

    // Restore scope
    CURRENT_SCOPE = CURRENT_SCOPE->parent_scope;

    // Increment loop counter for next for-loop
    CURRENT_SCOPE->for_loop_counter++;

    // Clean up
    MEMfree(adjusted_name);
    MEMfree(for_loop_start_name);
    MEMfree(for_loop_end_name);

    /**
     * Traverse init, cond and step children
     * Store init value (already emitted by child) in loop var
     * Store cond value (already emitted by child) in stack
     * Store step value (already emitted by child) in stack
     * Emit while label
     * Emit load instruction for loop var
     * Emit load instruction for cond value
     * Emit "if less than"
     * Emit jump to branch end (will trigger if loop should be broken)
     * Traverse body
     * Emit instruction for loop var increment
     * Emit jump to while label
     * Emit end while label
     */
    return node;
}

/**
 * @fn BCglobdecl
 */
node_st *BCglobdecl(node_st *node)
{
    TRAVchildren(node);

    /**
     * Save to imported variables stack
     * !!! Needs array handling
     */
    return node;
}

/**
 * @fn BCglobdef
 */
node_st *BCglobdef(node_st *node)
{
    TRAVchildren(node);

    /**
     * Match whether it has an expression:
     * --- No: Probably return since it's only here for the compiler to know the type
     * --- Yes: Treat as an assign; push value to globals stack
     * !!! Needs array handling
     */
    return node;
}

/**
 * @fn BCparam
 */
node_st *BCparam(node_st *node)
{
    TRAVchildren(node);

    /**
     * Variable as specified in funcall argument might already be on stack?
     * !!! Check this because I actually have no clue
     * !!! Needs array handling
     */
    return node;
}

/**
 * @fn BCvardecl
 */
node_st *BCvardecl(node_st *node)
{
    HAD_EXPR = false;
    TRAVchildren(node);

    if (HAD_EXPR) {
        char* name = VARDECL_NAME(node);
        const Symbol* s = STlookup(CURRENT_SCOPE, name);
#ifdef DEBUGGING
        ASSERT_MSG((s != NULL), "BYTECODE: Could not find symbol named %s", name);
#endif // DEBUGGING

        size_t current_level = CURRENT_SCOPE->nesting_level;
        size_t var_level = s->parent_scope->nesting_level;
        size_t var_offset = s->offset;
#ifdef DEBUGGING
        ASSERT_MSG((current_level == var_level),
            "BYTECODE: Symbol declaration %s, only found in different scope",
            name);
#endif // DEBUGGING

        char* instr = NULL;
        switch (s->vtype) {
            case VT_NUM: instr = STRcpy("i"); LAST_TYPE = VT_NUM; break;
            case VT_FLOAT: instr = STRcpy("f"); LAST_TYPE = VT_FLOAT; break;
            case VT_BOOL: instr = STRcpy("b"); LAST_TYPE = VT_BOOL; break;
            // TODO: ARRAYS
            default:  // Should not occur
#ifdef DEBUGGING
                ERROR("Incompatible Vardecl node with valuetype of %i", s->vtype);
#endif // DEBUGGING
        }

        instr = safe_concat_str(instr, STRcpy("store"));
        char* var_offset_str = int_to_str((int) var_offset);
        Instr(instr, var_offset_str, NULL, NULL);
        MEMfree(instr);
        MEMfree(var_offset_str);
    }

    /**
     * Match whether it has an expression:
     * --- No: Probably return since it's only here for the compiler to know the type
     * --- Yes: Treat as an assign; store value to variable
     * !!! Needs array handling
     */
    return node;
}

/**
 * @fn BCstmts
 */
node_st *BCstmts(node_st *node)
{
    TRAVchildren(node);

    /**
     * Do nothing
     */
    return node;
}

/**
 * @fn BCassign
 */
node_st *BCassign(node_st *node)
{
    TRAVexpr(node);
    TRAVlet(node);

    /**
     * Make sure expr is traversed before varlet
     */
    return node;
}

/**
 * @fn BCbinop
 */
node_st *BCbinop(node_st *node)
{
    TRAVleft(node);
    const ValueType left_value = LAST_TYPE;
    TRAVright(node);
    const ValueType right_value = LAST_TYPE;

#ifdef DEBUGGING
    ASSERT_MSG((left_value == right_value), "Left value and right value of types %i and %i don't match",
        left_value, right_value);
#endif // DEBUGGING

    char* instr;
    switch (left_value) {
        case VT_NUM: instr = STRcpy("i"); break;
        case VT_FLOAT: instr = STRcpy("f"); break;
        case VT_BOOL: instr = STRcpy("b"); break;
        default:  // Should never occur
#ifdef DEBUGGING
            ERROR("Unexpected binop valuetype %i", left_value);
#endif
    }

    switch (BINOP_OP(node)) {
        case BO_add:
            // badd is allowed; is logical disjunction of boolean values
            instr = safe_concat_str(instr, STRcpy("add"));
            break;
        case BO_sub:
#ifdef DEBUGGING
            if (left_value == VT_BOOL) ERROR("Subtraction was performed on boolean values");
#endif // DEBUGGING
            instr = safe_concat_str(instr, STRcpy("sub"));
            break;
        case BO_mul:
            // bmul is allowed; is logical conjunction of boolean values
            instr = safe_concat_str(instr, STRcpy("mul"));
            break;
        case BO_div:
#ifdef DEBUGGING
            if (left_value == VT_BOOL) ERROR("Division was performed on boolean values");
#endif // DEBUGGING
            instr = safe_concat_str(instr, STRcpy("div"));
            break;
        case BO_mod:
#ifdef DEBUGGING
            if (left_value == VT_BOOL) ERROR("Modulo was performed on boolean values");
            if (left_value == VT_FLOAT) ERROR("Modulo was performed on float values");
#endif // DEBUGGING
            instr = safe_concat_str(instr, STRcpy("rem"));
            break;
        case BO_lt:
#ifdef DEBUGGING
            if (left_value == VT_BOOL) ERROR("< operator was performed on boolean values");
#endif // DEBUGGING
            instr = safe_concat_str(instr, STRcpy("lt"));
            LAST_TYPE = VT_BOOL;
            break;
        case BO_le:
#ifdef DEBUGGING
            if (left_value == VT_BOOL) ERROR("<= operator was performed on boolean values");
#endif // DEBUGGING
            instr = safe_concat_str(instr, STRcpy("le"));
            LAST_TYPE = VT_BOOL;
            break;
        case BO_gt:
#ifdef DEBUGGING
            if (left_value == VT_BOOL) ERROR("> operator was performed on boolean values");
#endif // DEBUGGING
            instr = safe_concat_str(instr, STRcpy("gt"));
            LAST_TYPE = VT_BOOL;
            break;
        case BO_ge:
#ifdef DEBUGGING
            if (left_value == VT_BOOL) ERROR(">= operator was performed on boolean values");
#endif // DEBUGGING
            instr = safe_concat_str(instr, STRcpy("ge"));
            LAST_TYPE = VT_BOOL;
            break;
        case BO_eq:
            instr = safe_concat_str(instr, STRcpy("eq"));
            LAST_TYPE = VT_BOOL;
            break;
        case BO_ne:
            instr = safe_concat_str(instr, STRcpy("ne"));
            LAST_TYPE = VT_BOOL;
            break;
        case BO_and:
#ifdef DEBUGGING
            if (left_value == VT_NUM) ERROR("&& operator was performed on integer values");
            if (left_value == VT_FLOAT) ERROR("&& operator was performed on float values");
#endif // DEBUGGING
            instr = safe_concat_str(instr, STRcpy("mul"));
            break;
        case BO_or:
#ifdef DEBUGGING
            if (left_value == VT_NUM) ERROR("|| operator was performed on integer values");
            if (left_value == VT_FLOAT) ERROR("|| operator was performed on float values");
#endif // DEBUGGING
            instr = safe_concat_str(instr, STRcpy("add"));
            break;
        default:  // Should never happen
#ifdef DEBUGGING
            ERROR("Bytecode: Unexpected binop OP %i", BINOP_OP(node));
#endif // DEBUGGING
    }

    Instr(instr, NULL, NULL, NULL);

    MEMfree(instr);

    /**
     * Emit instruction for correct operator
     */
    return node;
}

/**
 * @fn BCmonop
 */
node_st *BCmonop(node_st *node)
{
    TRAVchildren(node);

    switch (MONOP_OP(node)) {
        case MO_neg: switch (LAST_TYPE) {
            case VT_NUM: Instr("ineg", NULL, NULL, NULL); break;
            case VT_FLOAT: Instr("fneg", NULL, NULL, NULL); break;
            default:
#ifdef DEBUGGING
                ERROR("Unexpected expression value %i for monop NEG", LAST_TYPE);
#endif // DEBUGGING
        } break;
        case MO_not:
            if (LAST_TYPE == VT_BOOL) Instr("bnot", NULL, NULL, NULL);
            else ERROR("Unexpected expression value %i for monop NOT", LAST_TYPE);
            break;
        default:  // Should never occur
#ifdef DEBUGGING
            ERROR("Unexpected monop OP %i", MONOP_OP(node));
#endif // DEBUGGING
    }

    // LAST_VALUE unchanged

    /**
     * Emit instruction for correct operator
     */
    return node;
}

/**
 * @fn BCvarlet
 */
node_st *BCvarlet(node_st *node)
{
    TRAVchildren(node);

    const Symbol* s = ScopeTreeFind(CURRENT_SCOPE, VARLET_NAME(node));
#ifdef DEBUGGING
    ASSERT_MSG((s != NULL), "BYTECODE: Could not find symbol named %s", VARLET_NAME(node));
#endif // DEBUGGING

    size_t current_level = CURRENT_SCOPE->nesting_level;
    size_t var_level = s->parent_scope->nesting_level;
    size_t var_offset = s->offset;

    char* instr = NULL;
    switch (s->vtype) {
        case VT_NUM: instr = STRcpy("i"); LAST_TYPE = VT_NUM; break;
        case VT_FLOAT: instr = STRcpy("f"); LAST_TYPE = VT_FLOAT; break;
        case VT_BOOL: instr = STRcpy("b"); LAST_TYPE = VT_BOOL; break;
        // TODO: ARRAYS
        default:  // Should not occur
#ifdef DEBUGGING
            ERROR("Incompatible Varlet node with valuetype of %i", s->vtype);
#endif // DEBUGGING
    }

    if (var_level == 0) {
        char* tmp_instr;
        if (s->imported) tmp_instr = STRcpy("storee");
        else tmp_instr = STRcpy("storeg");

        instr = safe_concat_str(instr, tmp_instr);
        char* var_offset_str = int_to_str((int) var_offset);
        Instr(instr, var_offset_str, NULL, NULL);
        MEMfree(var_offset_str);
    }

    else if (current_level == var_level) {
        instr = safe_concat_str(instr, STRcpy("store"));
        char* var_offset_str = int_to_str((int) var_offset);
        Instr(instr, var_offset_str, NULL, NULL);
        MEMfree(var_offset_str);
    }

    else {
#ifdef DEBUGGING
        ASSERT_MSG((current_level > var_level), "Calling variable from higher scope %lu compared to own scope %lu",
            var_level, current_level);
#endif // DEBUGGING
        instr = safe_concat_str(instr, STRcpy("storen"));
        char* var_delta_str = int_to_str((int) (current_level - var_level));
        Instr(instr, var_delta_str, int_to_str((int) var_offset), NULL);
        MEMfree(var_delta_str);
    }

    MEMfree(instr);

    /**
     * Find which scope variable is from
     * Match:
     * --- Own scope: find index of variable in scope + save using "Store Local Variable" (1.4.5)
     * --- Higher frame: find index of variable in scope + save using "Store Relatively Free Variable" (1.4.5)
     * --- Global: find index of variable in scope + save using "Store Global Variable" (1.4.5)
     * --- Imported: find index of variable in scope + save using "Store Imported Variable" (1.4.5)
     * !!! Needs array handling
     */
    return node;
}

/**
 * @fn BCvar
 */
node_st *BCvar(node_st *node)
{
    TRAVchildren(node);

    const Symbol* s = ScopeTreeFind(CURRENT_SCOPE, VAR_NAME(node));
#ifdef DEBUGGING
    ASSERT_MSG((s != NULL), "BYTECODE: Could not find symbol named %s", VAR_NAME(node));
#endif // DEBUGGING

    const size_t current_level = CURRENT_SCOPE->nesting_level;
    const size_t var_level = s->parent_scope->nesting_level;
    const size_t var_offset = s->offset;

    char* instr = NULL;
    switch (s->vtype) {
        case VT_NUM: instr = STRcpy("i"); LAST_TYPE = VT_NUM; break;
        case VT_FLOAT: instr = STRcpy("f"); LAST_TYPE = VT_FLOAT; break;
        case VT_BOOL: instr = STRcpy("b"); LAST_TYPE = VT_BOOL; break;
        // TODO: ARRAYS
        default:  // Should not occur
#ifdef DEBUGGING
            ERROR("Incompatible Var node with valuetype of %i", s->vtype);
#endif // DEBUGGING
            break;
    }

    if (var_level == 0) {
        if (s->imported) {
            instr = safe_concat_str(instr, STRcpy("loade"));
        } else {
            instr = safe_concat_str(instr, STRcpy("loadg"));
        }

        char* var_offset_str = int_to_str((int) var_offset);
        Instr(instr, var_offset_str, NULL, NULL);
        MEMfree(var_offset_str);
    }

    else if (current_level == var_level) {
        instr = safe_concat_str(instr, STRcpy("load"));
        if (var_offset <= 3) {
            switch (s->offset) {
                case 0: instr = safe_concat_str(instr, STRcpy("_0")); break;
                case 1: instr = safe_concat_str(instr, STRcpy("_1")); break;
                case 2: instr = safe_concat_str(instr, STRcpy("_2")); break;
                case 3: instr = safe_concat_str(instr, STRcpy("_3")); break;
                default:  // Should never happen
#ifdef DEBUGGING
                    ERROR("Var with offset %lu was deemed to be within 0 and 3 inclusive", var_offset);
#endif // DEBUGGING
            }
            Instr(instr, NULL, NULL, NULL);
        } else {
            char* var_offset_str = int_to_str((int) var_offset);
            Instr(instr, var_offset_str, NULL, NULL);
            MEMfree(var_offset_str);
        }
    }

    else {
#ifdef DEBUGGING
        ASSERT_MSG((current_level > var_level), "Calling variable from higher scope %lu compared to own scope %lu",
            var_level, current_level);
#endif // DEBUGGING
        instr = safe_concat_str(instr, STRcpy("loadn"));
        char* delta_offset_str = int_to_str((int) (current_level - var_level));
        char* var_offset_str = int_to_str((int) var_offset);
        Instr(instr, delta_offset_str, var_offset_str, NULL);
        MEMfree(delta_offset_str);
        MEMfree(var_offset_str);
    }

    MEMfree(instr);

    HAD_EXPR = true;

    /**
     * Find which scope variable is from
     * Match:
     * --- Own scope: find index of variable in scope + load using "Load Local Variable" (1.4.5)
     * --- Higher frame: find index of variable in scope + load using "Load Relatively Free Variable" (1.4.5)
     * --- Global: find index of variable in scope + load using "Load Global Variable" (1.4.5)
     * --- Imported: find index of variable in scope + load using "Load Imported Variable" (1.4.5)
     * !!! Needs array handling
     */
    return node;
}

/**
 * @fn BCnum
 */
node_st *BCnum(node_st *node)
{
    TRAVchildren(node);

    /**
     * Emit constant
     * Emit instruction to load constant
     */

    const int v = NUM_VAL(node);
    switch (v) {
        case -1: Instr("iloadc_m1", NULL, NULL, NULL); break;
        case 0: Instr("iloadc_0", NULL, NULL, NULL); break;
        case 1: Instr("iloadc_1", NULL, NULL, NULL); break;
        default: ;  // Don't remove this semicolon, it's here because a statement is expected
                    // and the declaration after is not a statement so the semicolon serves
                    // as an empty statement :)
            char* val_str = int_to_str(v);

            // Refer to existing constant if possible
            ConstEntry res = ASMfindConstant(&ASM, val_str);

            char* const_count_str;
            if (res.get != NULL) {
                const_count_str = int_to_str((int) res.offset);
            } else {
                ASMemitConst(&ASM, "int", val_str);
                const_count_str = int_to_str((int) CONST_COUNT++);
            }

            Instr("iloadc", const_count_str, NULL, NULL);

            MEMfree(val_str);
            MEMfree(const_count_str);
            break;
    }

    LAST_TYPE = VT_NUM;
    HAD_EXPR = true;

    return node;
}

/**
 * @fn BCfloat
 */
node_st *BCfloat(node_st *node)
{
    TRAVchildren(node);

    /**
     * Emit constant
     * Emit instruction to load constant
     */

    const float v = FLOAT_VAL(node);
    if (v == 0.0) Instr("floadc_0", NULL, NULL, NULL);
    else if (v == 1.0) Instr("floadc_1", NULL, NULL, NULL);
    else {
        char* val_str = float_to_str(v);

        // Refer to existing constant if possible
        ConstEntry res = ASMfindConstant(&ASM, val_str);

        char* const_count_str;
        if (res.get != NULL) {
           const_count_str = int_to_str((int) res.offset);
        } else {
            ASMemitConst(&ASM, "float", val_str);
            const_count_str = int_to_str((int) CONST_COUNT++);
        }

        Instr("floadc", const_count_str, NULL, NULL);

        MEMfree(val_str);
        MEMfree(const_count_str);
    }

    LAST_TYPE = VT_FLOAT;
    HAD_EXPR = true;

    return node;
}

/**
 * @fn BCbool
 */
node_st *BCbool(node_st *node)
{
    TRAVchildren(node);

    /**
     * Emit constant
     * Emit instruction to load constant
     */

    if (BOOL_VAL(node) == true) {
        Instr("bloadc_t", NULL, NULL, NULL);
    } else {
        Instr("bloadc_f", NULL, NULL, NULL);
    }

    LAST_TYPE = VT_BOOL;
    HAD_EXPR = true;

    return node;
}

