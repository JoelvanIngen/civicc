/**
 * @file
 *
 * Traversal: ByteCodeGeneration
 * UID      : BC
 *
 *
 */

#include "ccn/ccn.h"
#include "ccngen/ast.h"
#include "ccngen/trav.h"

#include "common.h"
#include "asm.h"
#include "writer.h"
#include "global/globals.h"
#include "symbol/scopetree.h"
#include "symbol/table.h"

#define MAX_STR_LEN 100

static FILE* ASM_FILE;
static Assembly ASM;

static SymbolTable* CURRENT_SCOPE;

static size_t CONST_COUNT = 0;
static size_t IMPORTVAR_COUNT = 0;

static size_t NUMBERED_LABEL_COUNT = 0;

static ValueType LAST_TYPE = VT_NULL;

// Shortcuts to prevent having to provide asm as argument every call
void Instr(char* instr_name, char* arg0, char* arg1, char* arg2) {
    ASMemitInstr(&ASM, instr_name, arg0, arg1, arg2);
}

void Label(char* label) {
    ASMemitLabel(&ASM, label);
}

char* float_to_str(const float f) {
    char* buf = MEMmalloc(MAX_STR_LEN);
    snprintf(buf, MAX_STR_LEN, "%f", f);
    return buf;
}

char* int_to_str(const int i) {
    char* buf = MEMmalloc(MAX_STR_LEN);
    snprintf(buf, MAX_STR_LEN, "%i", i);
    return buf;
}

/**
 * Concatenates two strings and frees them
 * @param s1 first string
 * @param s2 second string
 * @return concatenated strings
 */
char* safe_concat_str(char* s1, char* s2) {
    char* buf = MEMmalloc(MAX_STR_LEN);
    snprintf(buf, MAX_STR_LEN, "%s%s", s1, s2);
    MEMfree(s1);
    MEMfree(s2);
    return buf;
}

/**
 * Generates a guaranteed unique name for any given nested function that
 * cannot be generated by a user function
 * @param s function header symbol to generate name for
 * @return unique name
 */
char* generate_unique_fun_name(const Symbol* s) {
    // Don't generate name for global function
    if (s->parent_scope->parent_fun == NULL) return s->name;

    char* name = STRcpy(s->name);
    while (s->parent_scope->parent_fun != NULL) {
        s = s->parent_scope->parent_fun;
        name = safe_concat_str(s->name, name);
    }

    return safe_concat_str("_", name);
}

void add_importvars() {
    // Run loop multiple times to get the highest offset imported since they are not stored in order
    // in the hashtable, but they need to be written to the file in order
    int highest_found = -1;
    int highest_saved = -1;

    do {
        for (htable_iter_st *iter = HTiterate(GB_GLOBAL_SCOPE->table); iter;
                iter = HTiterateNext(iter)) {
            const Symbol *s = HTiterValue(iter);

            if (s->imported) {
                if (s->offset > highest_found) highest_found = (int) s->offset;
                if (s->offset == highest_saved + 1) {
                    // TODO: Save the thing
                    highest_saved++;
                }
            }
        }
    } while (highest_found != highest_saved);
}

static void init() {
    CURRENT_SCOPE = GB_GLOBAL_SCOPE;

    add_importvars();
}

static void fini() {
    // TODO: probably make filename command-line argument
    ASM_FILE = fopen("bytecode.asm", "w");
    if (ASM_FILE == NULL) {
        fprintf(stderr, "Error creating bytecode file");
        exit(1);
    }
    write_assembly(ASM_FILE, &ASM);
    fclose(ASM_FILE);
}

/**
 * @fn BCprogram
 */
node_st *BCprogram(node_st *node)
{
    init();

    TRAVchildren(node);

    // Write collected ASM to file
    fini();
    return node;
}

/**
 * @fn BCdecls
 */
node_st *BCdecls(node_st *node)
{
    TRAVchildren(node);

    /**
     * Do nothing
     */
    return node;
}

/**
 * @fn BCexprs
 */
node_st *BCexprs(node_st *node)
{
    TRAVchildren(node);

    /**
     * Do nothing
     */
    return node;
}

/**
 * @fn BCarrexpr
 */
node_st *BCarrexpr(node_st *node)
{
    TRAVchildren(node);

    /**
     * TODO: No idea
     */
    return node;
}

/**
 * @fn BCids
 */
node_st *BCids(node_st *node)
{
    TRAVchildren(node);

    /**
     * TODO: No idea
     */
    return node;
}

/**
 * @fn BCexprstmt
 */
node_st *BCexprstmt(node_st *node)
{
    TRAVchildren(node);
    return node;
}

/**
 * @fn BCreturn
 */
node_st *BCreturn(node_st *node)
{
    TRAVchildren(node);

    switch (CURRENT_SCOPE->parent_fun->vtype) {
        case VT_NUM: Instr("ireturn", NULL, NULL, NULL); break;
        case VT_FLOAT: Instr("freturn", NULL, NULL, NULL); break;
        case VT_BOOL: Instr("breturn", NULL, NULL, NULL); break;
        case VT_VOID: Instr("return", NULL, NULL, NULL); break;
        default:  // Should never occur
#ifdef DEBUGGING
            ERROR("Unexpected return valuetype %i", CURRENT_SCOPE->parent_fun->vtype);
#endif // DEBUGGING
    }

    /**
     * Emit return instruction (with correct type)
     */
    return node;
}

/**
 * @fn BCfuncall
 */
node_st *BCfuncall(node_st *node)
{
    TRAVchildren(node);

    /**
     * For each argument:
     * -- Emit load for argument
     * Find out which scope function is from for funcall instruction?
     * Emit funcall instruction with amount of vars added
     */
    return node;
}

/**
 * @fn BCcast
 */
node_st *BCcast(node_st *node)
{
    TRAVchildren(node);

    /**
     * Traverse children
     * Emit cast
     */
    return node;
}

/**
 * @fn BCfundefs
 */
node_st *BCfundefs(node_st *node)
{
    TRAVchildren(node);

    /**
     * Do nothing
     */
    return node;
}

/**
 * @fn BCfundef
 */
node_st *BCfundef(node_st *node)
{
    char* name = FUNDEF_NAME(node);
    const Symbol* fun_symbol = ScopeTreeFind(CURRENT_SCOPE, name);

    // Switch scope
    SymbolTable* prev_scope = CURRENT_SCOPE;
    CURRENT_SCOPE = fun_symbol->as.fun.scope;

    TRAVchildren(node);

    // Revert scope
    CURRENT_SCOPE = prev_scope;

    /**
    * Do nothing?
    */
    return node;
}

/**
 * @fn BCfunbody
 */
node_st *BCfunbody(node_st *node)
{
    TRAVlocal_fundefs(node);

    Label(generate_unique_fun_name(CURRENT_SCOPE->parent_fun));
    Instr("esr", int_to_str((int) CURRENT_SCOPE->offset_counter), NULL, NULL);

    TRAVdecls(node);
    TRAVstmts(node);

    /**
     * Traverse nested functions (otherwise functions mix in bytecode)
     * Emit function label
     * Emit "esr N" with N being the amount of variables we are going to use in function
     * Traverse decls and stmts
     * !!! TODO: figure out a way to find the amount of variables used in function || Solved?
     * !!! TODO: figure out if for-loop variables count for that purpose (would make everything a tad trickier)
     */
    return node;
}

/**
 * @fn BCifelse
 */
node_st *BCifelse(node_st *node)
{
    TRAVchildren(node);

    /**
     * Traverse cond child
     * Emit jump to label else if false
     * Traverse then child
     * Emit unconditional jump to label endif
     * Emit label else
     * Traverse else child (might be empty which yields same result following these steps)
     * Emit label endif
     */
    return node;
}

/**
 * @fn BCwhile
 */
node_st *BCwhile(node_st *node)
{
    TRAVchildren(node);

    /**
     * Emit loop start label
     * Traverse body
     * Traverse cond child
     * Emit jump to loop end label if false (expr will have resolved to boolean)
     * Emit unconditional jump to loop start label
     * Emit loop end label
     */
    return node;
}

/**
 * @fn BCdowhile
 */
node_st *BCdowhile(node_st *node)
{
    TRAVchildren(node);

    /**
     * Emit loop start label
     * Traverse cond child
     * Emit jump to loop end label if false (expr will have resolved to boolean)
     * Traverse body
     * Emit unconditional jump to loop start label
     * Emit loop end label
     */
    return node;
}

/**
 * @fn BCfor
 */
node_st *BCfor(node_st *node)
{
    TRAVchildren(node);

    /**
     * Traverse init, cond and step children
     * Store init value (already emitted by child) in loop var
     * Store cond value (already emitted by child) in stack
     * Store step value (already emitted by child) in stack
     * Emit while label
     * Emit load instruction for loop var
     * Emit load instruction for cond value
     * Emit "if less than"
     * Emit jump to branch end (will trigger if loop should be broken)
     * Traverse body
     * Emit instruction for loop var increment
     * Emit jump to while label
     * Emit end while label
     */
    return node;
}

/**
 * @fn BCglobdecl
 */
node_st *BCglobdecl(node_st *node)
{
    TRAVchildren(node);

    /**
     * Save to imported variables stack
     * !!! Needs array handling
     */
    return node;
}

/**
 * @fn BCglobdef
 */
node_st *BCglobdef(node_st *node)
{
    TRAVchildren(node);

    /**
     * Match whether it has an expression:
     * --- No: Probably return since it's only here for the compiler to know the type
     * --- Yes: Treat as an assign; push value to globals stack
     * !!! Needs array handling
     */
    return node;
}

/**
 * @fn BCparam
 */
node_st *BCparam(node_st *node)
{
    TRAVchildren(node);

    /**
     * Variable as specified in funcall argument might already be on stack?
     * !!! Check this because I actually have no clue
     * !!! Needs array handling
     */
    return node;
}

/**
 * @fn BCvardecl
 */
node_st *BCvardecl(node_st *node)
{
    TRAVchildren(node);

    /**
     * Match whether it has an expression:
     * --- No: Probably return since it's only here for the compiler to know the type
     * --- Yes: Treat as an assign; push value to stack
     * !!! Needs array handling
     */
    return node;
}

/**
 * @fn BCstmts
 */
node_st *BCstmts(node_st *node)
{
    TRAVchildren(node);

    /**
     * Do nothing
     */
    return node;
}

/**
 * @fn BCassign
 */
node_st *BCassign(node_st *node)
{
    TRAVexpr(node);
    TRAVlet(node);

    /**
     * Make sure expr is traversed before varlet
     */
    return node;
}

/**
 * @fn BCbinop
 */
node_st *BCbinop(node_st *node)
{
    // TODO: Finish implementation

    TRAVleft(node);
    const ValueType left_value = LAST_TYPE;
    TRAVright(node);
    const ValueType right_value = LAST_TYPE;

    switch (BINOP_OP(node)) {
        case BO_add:
            break;
        case BO_sub:
            break;
        case BO_mul:
            break;
        case BO_div:
            break;
        case BO_mod:
            break;
        case BO_lt:
            break;
        case BO_le:
            break;
        case BO_gt:
            break;
        case BO_ge:
            break;
        case BO_eq:
            break;
        case BO_ne:
            break;
        case BO_and:
            break;
        case BO_or:
            break;
        default:  // Should never happen
#ifdef DEBUGGING:
            ERROR("Bytecode: Unexpected binop OP %i", BINOP_OP(node));
#endif // DEBUGGING
    }

    /**
     * Emit instruction for correct operator
     */
    return node;
}

/**
 * @fn BCmonop
 */
node_st *BCmonop(node_st *node)
{
    TRAVchildren(node);

    switch (MONOP_OP(node)) {
        case MO_neg: switch (LAST_TYPE) {
            case VT_NUM: Instr("ineg", NULL, NULL, NULL); break;
            case VT_FLOAT: Instr("fneg", NULL, NULL, NULL); break;
            default:
#ifdef DEBUGGING
                ERROR("Unexpected expression value %i for monop NEG", LAST_TYPE);
#endif // DEBUGGING
        } break;
        case MO_not:
            if (LAST_TYPE == VT_BOOL) Instr("bnot", NULL, NULL, NULL);
            else ERROR("Unexpected expression value %i for monop NOT", LAST_TYPE);
            break;
        default:  // Should never occur
#ifdef DEBUGGING
            ERROR("Unexpected monop OP %i", MONOP_OP(node));
#endif // DEBUGGING
    }

    // LAST_VALUE unchanged

    /**
     * Emit instruction for correct operator
     */
    return node;
}

/**
 * @fn BCvarlet
 */
node_st *BCvarlet(node_st *node)
{
    TRAVchildren(node);

    const Symbol* s = ScopeTreeFind(CURRENT_SCOPE, VARLET_NAME(node));
#ifdef DEBUGGING
    ASSERT_MSG((s != NULL), "BYTECODE: Could not find symbol named %s", VARLET_NAME(node));
#endif // DEBUGGING

    size_t current_level = CURRENT_SCOPE->nesting_level;
    size_t var_level = s->parent_scope->nesting_level;
    size_t var_offset = s->offset;

    char* instr = NULL;
    switch (s->vtype) {
        case VT_NUM: instr = "i"; LAST_TYPE = VT_NUM; break;
        case VT_FLOAT: instr = "f"; LAST_TYPE = VT_FLOAT; break;
        case VT_BOOL: instr = "b"; LAST_TYPE = VT_BOOL; break;
        // TODO: ARRAYS
        default:  // Should not occur
#ifdef DEBUGGING
            ERROR("Incompatible Varlet node with valuetype of %i", s->vtype);
#endif // DEBUGGING
            break;
    }

    if (var_level == 0) {
        if (s->imported) {
            instr = safe_concat_str(instr, "storee");
        } else {
            instr = safe_concat_str(instr, "storeg");
        }

        Instr(instr, int_to_str((int) var_offset), NULL, NULL);
    }

    else if (current_level == var_level) {
        instr = safe_concat_str(instr, "store");
        Instr(instr, int_to_str((int) var_offset), NULL, NULL);
    }

    else {
#ifdef DEBUGGING
        ASSERT_MSG((current_level > var_level), "Calling variable from higher scope %lu compared to own scope %lu",
            var_level, current_level);
#endif // DEBUGGING
        instr = safe_concat_str(instr, "storen");
        Instr(instr, int_to_str((int) (current_level - var_level)), int_to_str((int) var_offset), NULL);
    }

    /**
     * Find which scope variable is from
     * Match:
     * --- Own scope: find index of variable in scope + save using "Store Local Variable" (1.4.5)
     * --- Higher frame: find index of variable in scope + save using "Store Relatively Free Variable" (1.4.5)
     * --- Global: find index of variable in scope + save using "Store Global Variable" (1.4.5)
     * --- Imported: find index of variable in scope + save using "Store Imported Variable" (1.4.5)
     * !!! Needs array handling
     */
    return node;
}

/**
 * @fn BCvar
 */
node_st *BCvar(node_st *node)
{
    TRAVchildren(node);

    const Symbol* s = ScopeTreeFind(CURRENT_SCOPE, VAR_NAME(node));
#ifdef DEBUGGING
    ASSERT_MSG((s != NULL), "BYTECODE: Could not find symbol named %s", VAR_NAME(node));
#endif // DEBUGGING

    const size_t current_level = CURRENT_SCOPE->nesting_level;
    const size_t var_level = s->parent_scope->nesting_level;
    const size_t var_offset = s->offset;

    char* instr = NULL;
    switch (s->vtype) {
        case VT_NUM: instr = "i"; LAST_TYPE = VT_NUM; break;
        case VT_FLOAT: instr = "f"; LAST_TYPE = VT_FLOAT; break;
        case VT_BOOL: instr = "b"; LAST_TYPE = VT_BOOL; break;
        // TODO: ARRAYS
        default:  // Should not occur
#ifdef DEBUGGING
            ERROR("Incompatible Var node with valuetype of %i", s->vtype);
#endif // DEBUGGING
            break;
    }

    if (var_level == 0) {
        if (s->imported) {
            instr = safe_concat_str(instr, "loade");
        } else {
            instr = safe_concat_str(instr, "loadg");
        }

        Instr(instr, int_to_str((int) var_offset), NULL, NULL);
    }

    else if (current_level == var_level) {
        instr = safe_concat_str(instr, "load");
        if (var_offset <= 3) {
            switch (s->offset) {
                case 0: instr = safe_concat_str(instr, "_0"); break;
                case 1: instr = safe_concat_str(instr, "_1"); break;
                case 2: instr = safe_concat_str(instr, "_2"); break;
                case 3: instr = safe_concat_str(instr, "_3"); break;
                default:  // Should never happen
#ifdef DEBUGGING
                    ERROR("Var with offset %lu was deemed to be within 0 and 3 inclusive");
#endif // DEBUGGING
            }
            Instr(instr, NULL, NULL, NULL);
        } else {
            Instr(instr, int_to_str((int) var_offset), NULL, NULL);
        }
    }

    else {
#ifdef DEBUGGING
        ASSERT_MSG((current_level > var_level), "Calling variable from higher scope %lu compared to own scope %lu",
            var_level, current_level);
#endif // DEBUGGING
        instr = safe_concat_str(instr, "loadn");
        Instr(instr, int_to_str((int) (current_level - var_level)), int_to_str((int) var_offset), NULL);
    }

    MEMfree(instr);

    /**
     * Find which scope variable is from
     * Match:
     * --- Own scope: find index of variable in scope + load using "Load Local Variable" (1.4.5)
     * --- Higher frame: find index of variable in scope + load using "Load Relatively Free Variable" (1.4.5)
     * --- Global: find index of variable in scope + load using "Load Global Variable" (1.4.5)
     * --- Imported: find index of variable in scope + load using "Load Imported Variable" (1.4.5)
     * !!! Needs array handling
     */
    return node;
}

/**
 * @fn BCnum
 */
node_st *BCnum(node_st *node)
{
    TRAVchildren(node);

    /**
     * Emit constant
     * Emit instruction to load constant
     */

    const int v = NUM_VAL(node);
    switch (v) {
        case -1: Instr("iloadc_m1", NULL, NULL, NULL); break;
        case 0: Instr("iloadc_0", NULL, NULL, NULL); break;
        case 1: Instr("iloadc_1", NULL, NULL, NULL); break;
        default:
            ASMemitConst(&ASM, "int", int_to_str(v));
        Instr("iloadc", int_to_str((int) CONST_COUNT++), NULL, NULL); break;
    }

    LAST_TYPE = VT_NUM;

    return node;
}

/**
 * @fn BCfloat
 */
node_st *BCfloat(node_st *node)
{
    TRAVchildren(node);

    /**
     * Emit constant
     * Emit instruction to load constant
     */

    const float v = FLOAT_VAL(node);
    switch (v) {
        case 0.0: Instr("floadc_0", NULL, NULL, NULL); break;
        case 1.0: Instr("floadc_1", NULL, NULL, NULL); break;
        default:
            ASMemitConst(&ASM, "float", float_to_str(v));
            Instr("floadc", int_to_str((int) CONST_COUNT++), NULL, NULL); break;
    }

    LAST_TYPE = VT_FLOAT;

    return node;
}

/**
 * @fn BCbool
 */
node_st *BCbool(node_st *node)
{
    TRAVchildren(node);

    /**
     * Emit constant
     * Emit instruction to load constant
     */

    if (BOOL_VAL(node) == true) {
        Instr("bloadc_t", NULL, NULL, NULL);
    } else {
        Instr("bloadc_f", NULL, NULL, NULL);
    }

    LAST_TYPE = VT_BOOL;

    return node;
}

